# SE Terminology

- {Don't repeat yourself} ({DRY})
	- a principle of {software development} aimed at {reducing repetition} of software patterns replacing it with abstractions or using data normalization to avoid {redundancy}
- Violations of the above are typically referred to as {WET} solutions, which is commonly taken to stand for "{we enjoy typing}"
<!--ID: 1639920234646-->

- {application family} 
	- A set of software application programs that have a common architecture and generic functionality. 
	- These can be tailored to the needs of specific customers by modifying components and program parameters.
<!--ID: 1640126670812-->


- {bar chart} ({Gantt chart})
	- A chart used by project managers to show
		- project tasks
		- the schedule associated with these tasks
		- the people who will work on them
	- It shows the tasks’ start and end dates and the staff allocations against a timeline.	
<!--ID: 1640126670852-->


- {change management} 
	- A process to record, check, analyze, estimate and implement proposed changes to a software system.	
<!--ID: 1640126670877-->


- {class diagram} 
	- A {UML} diagram types that shows the object classes in a system and their relationships	
<!--ID: 1640126670900-->


- {CMMI} 
	- An integrated approach to process capability maturity modeling based on the adoption of good software engineering practice and integrated quality management. 
	- It supports discrete and continuous maturity modeling and integrates systems and software engineering process maturity models.
<!--ID: 1640126670926-->

- {CMM} was originally developed as a tool for objectively assessing the ability of government contractors' {processes} to implement a contracted {software} project
	- A maturity model can be viewed as a set of structured levels that describe how well the behaviors, practices and processes of an organization can reliably and sustainably produce required {outcomes} used to assess the level of software development maturity in an organization. 
	- It has now been superseded by {CMMI}, but is still widely used
	- The maturity of a software company’s processes reflects the process management, measurement, and use of good software engineering practices in the company 
<!--ID: 1640133749269-->


- {Constructive Cost Modeling} ({COCOMO}) 
	- A family of algorithmic cost estimation models. 
	- It was first proposed in the early-1980s and has been modified and updated since then to reflect new technology and changing software engineering practice. 
	- COCOMO II is its latest instantiation and is a freely available algorithmic cost estimation model that is supported by open source software tools	
<!--ID: 1640126670949-->


- {dependability} 
	- ... of a system is an aggregate property that takes into account the system’s safety, reliability, availability, security, resilience and other attributes. 
<!--ID: 1640126670977-->


- {embedded} system
	- A software system that is embedded in a hardware device e.g. the software system in a cell phone. 
	- These systems are usually real-time systems and so have to respond in a timely way to events occurring in their environment.	
<!--ID: 1640126671007-->


- {extreme programming} ({XP})  ^6d14c9
	- A widely-used agile method of software development that includes practices such as scenario-based requirements, test-first development and pair programming.	
<!--ID: 1640126671035-->
 ^131b2d

- {GitHub} 
	- A server that maintains a large number of Git repositories. 
	- Repositories may be private or public. 
	- The repositories for many open-source projects are maintained on GitHub.	
<!--ID: 1640126671064-->


- {maintenance} 
	- The process of making changes to a system after it has been put into operation.	
<!--ID: 1640126671090-->


- {model-driven architecture} ({MDA}) 
	- An approach to software development based on the construction of a set of system models, which can be automatically or semi-automatically processed to generate an executable system	
<!--ID: 1640126671119-->


- {pair programming} 
	- A development situation where programmers work in pairs, rather than individually, to develop code. 
	- A fundamental part of Extreme Programming
<!--ID: 1640126671144-->


- {People Capability Maturity Model} ({P-CMM}) 
	- A process maturity model that reflects how effective an organization is at managing the skills, training and experience of the people in that organization.	
<!--ID: 1640126671166-->


- {plan-driven process} 
	- A software process where all of the process activities are planned before the software is developed.	
<!--ID: 1640126671188-->


- {planning game} 
	- An approach to project planning based on estimating the time required to implement user stories. 
	- Used in some agile methods.	
<!--ID: 1640126671211-->


- {process improvement} 
	- Changing a software development process with the aim of making that process more efficient or improving the quality of its outputs. 
	- E.g., if your aim is to reduce the number of defects in the delivered software, you might improve a process by adding new validation activities.	
<!--ID: 1640126671236-->


- {process maturity model} 
	- A model of the extent to which a process includes good practice and reflective and measurement capabilities that are geared to process improvement.	
<!--ID: 1640126671265-->


- {quality plan} 
	- A plan that defines the quality processes and procedures that should be used. 
	- This involves selecting and instantiating standards for products and processes and defining the system quality attributes that are most important.	
<!--ID: 1640126671292-->


- {refactoring} 
	- Modifying a program to improve its structure and readability without changing its functionality.	
<!--ID: 1640126671318-->


- {reliability} 
	- The ability of a system to deliver services as specified. 
	- It can be specified quantitatively as a probability of failure on demand or as the rate of occurrence of failure.	
<!--ID: 1640126671348-->


- {requirement, functional} 
	- A statement of some function or feature that should be implemented in a system.	
<!--ID: 1640126671375-->


- {requirement, non-functional} 
	- A statement of a constraint or expected behavior that applies to a system. 
	- This constraint may refer to the emergent properties of the software that is being developed or to the development process.	
<!--ID: 1640126671401-->


- {requirements management} 
	- The process of managing changes to requirements to ensure that the changes made are properly analyzed and tracked through the system.	
<!--ID: 1640126671423-->


- {risk} 
	- An undesirable outcome that poses a threat to the achievement of some objective. 
		- A process risk threatens the schedule or cost of a process
		- A product risk is a risk that may mean that some of the system requirements may not be achieved. 
		- A safety risk is a measure of the probability that a hazard will lead to an accident.	
<!--ID: 1640126671443-->


- {risk management} 
	- The process of identifying risks, assessing their severity, planning measures to put in place if the risks arise and monitoring the software and the software process for risks.	
<!--ID: 1640126671463-->


- {scenario testing} 
	- An approach to software testing where test cases are derived from a scenario of system use.	
<!--ID: 1640126671486-->


- {sequence diagram} 
	- A diagram that shows the sequence of interactions required to complete some operation. 
	- In the UML, these diagrams may be associated with use cases.	
<!--ID: 1640126671508-->


- {software development life cycle} 
	- Often used as another name for the {software process}. 
	- Originally coined to refer to the waterfall model of the software process.	
<!--ID: 1640126671535-->


- {software process} 
	- The activities and processes that are involved in developing and evolving a software system.	
<!--ID: 1640126671558-->


- {spiral model} 
	- A model of a development process where the process is represented as a spiral, with each round of the spiral incorporating the different stages in the process. 
	- As you move from one round of the spiral to another, you repeat all of the stages of the process.	
<!--ID: 1640126671580-->


- {systems engineering} 
	- A process that is concerned with specifying a system, integrating its components and testing that the system meets its requirements. 
	- It is concerned with the whole socio-technical system—software, hardware and operational processes—not just the system software.	
<!--ID: 1640126671603-->


- {test coverage} 
	- The effectiveness of system tests in testing the code of an entire system. 
	- Some companies have standards for test coverage e.g. the system tests shall ensure that all program statements are executed at least once.	
<!--ID: 1640126671624-->


- {Unified Modeling Language} ({UML}) 
	- A graphical language used in object-oriented development that includes several types of system model that provide different views of a system. 
	- It has become a de facto standard for object-oriented modeling.	
<!--ID: 1640126671648-->


- {use case} 
	- A specification of one type of interaction with a system.	
<!--ID: 1640126671679-->


- {use-case diagram} 
	- A UML diagram type that is used to identify use-cases and graphically depict the users involved. 
	- It must be supplemented with additional information to completely describe use-cases.	
<!--ID: 1640126671702-->


- {user interface design} 
	- The process of designing the way in which system users can access system functionality, and the way that information produced by the system is displayed.	
<!--ID: 1640126671730-->


- {user story} 
	- A natural language description of a situation that explains how a system or systems might be used and the interactions with the systems that might take place.	
<!--ID: 1640126671753-->


- {verification} 
	- The process of checking that a system meets its specification.	
<!--ID: 1640126671777-->


- {waterfall model} 
	- A {software process} model that involves discrete development stages: 
		- specification, 
		- design, 
		- implementation, 
		- testing 
		- and maintenance. 
	- In principle, one stage must be complete before progress to the next stage is possible. In practice, there is significant iteration between stages.	
<!--ID: 1640126671801-->


- Where does process quality come in Scrum? 
	- software process — a coherent set of activities for software production 
		- {Sprint Planning} 
			- In agile processes, planning is incremental and continual as the software is developed easier to change the process to reflect changing customer or product requirements
		- {Daily Scrum} 
			- scrum master hosts, 15 minutes. 
			- team discuss work completed previous day, planned work next day, and issues faced during a sprint.
		- {Sprint Review/Retrospective} 
			- display new product increment stakeholders and Scrum Team talk about what was done in Sprint dev team estimates size of work w Product Owner	
<!--ID: 1640126671822-->


- {Scrum Master} 
	- responsible for ensuring that the Scrum {process} is followed
	- guides the team in the effective use of Scrum interfaces with rest of the company
	- ensures that Scrum team is not diverted by outside {interference}	
<!--ID: 1640126671844-->

- {Scrum}
	- An {agile} method of development, which is based on sprints – short development, cycles. 
	- {Scrum} may be used as a basis for {agile} project management alongside other {agile} methods such as XP
<!--ID: 1640133749300-->


- {defect rate}
	- is the percentage of output that fails to meet a quality target
	- It can be used to evaluate and control programs, projects, production, services and processes. 
	- Software testing tests 500,000 lines of code and discovers 33 defects (defect rate = (33/500000) × 100 = 0.0066%)
<!--ID: 1640126671866-->


- {agile manifesto}
	- A set of principles encapsulating the ideas underlying agile methods of software development
<!--ID: 1640133749318-->


- {algorithmic cost modeling} 
	- An approach to software cost estimation where a formula is used to estimate the project cost. 
	- The parameters in the formula are attributes of the project and the software itself.	
<!--ID: 1640133749335-->


- {application program interface} ({API}) 
	- An interface, generally specified as a set of operations, that allows access to an application program’s functionality. This means that this functionality can be called on directly by other programs and not just accessed through the user interface.	
<!--ID: 1640133749352-->


- {availability} 
	- The readiness of a system to deliver services when requested. usually expressed as a decimal number, so an availability of 0.999 means that the system can deliver services for 999 out of 1000 time units.	
<!--ID: 1640133749385-->


- {configuration management} 
	- The process of managing the changes to an evolving software product
	- involves version management, system building, change management and release management.	
<!--ID: 1640133749416-->


- {Git} 
	- A distributed version management and system building tool where developers take complete copies of the project repository to allow concurrent working.	
<!--ID: 1640133749435-->


- {incremental development} 
	- An approach to software development where the software is delivered and deployed in increments.	
<!--ID: 1640133749463-->


- {interface} 
	- A specification of the attributes and operations associated with a software component
	- used as the means of accessing the component’s functionality.	
<!--ID: 1640133749489-->


- {iterative} development 
	- An approach to software development where the processes of specification, design, programming and testing are interleaved.	
<!--ID: 1640133749504-->


- {process model} 
	- An abstract representation of a process. 
	- Process models may be developed from various perspectives and can show the activities involved in a process, the artifacts used in the process, constraints that apply to the process, and the roles of the people enacting the process.	
<!--ID: 1640133749514-->


- {quality management} ({QM}) 
	- The set of processes concerned with defining how software quality can be achieved and how the organization developing the software knows that the software has met the required level of quality.	
<!--ID: 1640133749533-->


- {system building} 
	- The process of compiling the components or units that make up a system and linking these with other components to create an executable program. {System building} is normally automated so that recompilation is minimized. This automation may be built in to the language processing system (as in Java) or may involve software tools to support system building.	
<!--ID: 1640133749595-->


- {system testing} 
	- The testing of a completed system before it is delivered to customers.	
<!--ID: 1640133749766-->


- {test-driven development} 
	- An approach to software development where executable tests are written before the program code. The set of tests are run automatically after every change to the program.	
<!--ID: 1640133749792-->

- {validation} 
	- The process of checking that a system meets the needs and expectations of the customer.	
<!--ID: 1640133749841-->

- {version control} 
	- The process of managing changes to a software system and its components so that it is possible to know which changes have been implemented in each version of the component/system, and also to recover/recreate previous versions of the component/system.	
<!--ID: 1640133749879-->

- {ISO 9000/9001}
	- A set of standards for {quality management processes} that is defined by the International Standards Organization (ISO). 
	- ISO 9001 is the ISO standard that is most applicable to software development. 
	- These may be used to certify the quality management processes in an organization. 
<!--ID: 1640133749919-->


- {REST} ({Representational State Transfer}) 
	- a style of development based around simple client/server interaction which uses the HTTP protocol for communications. 
		- based around the idea of an identifiable resource, which has a URI. 
		- All interaction with resources is based on HTTP POST, GET, PUT and DELETE. 
		- Widely used for implementing low overhead web services (RESTful services).
<!--ID: 1640133749971-->


- {Black} box testing
	- you don't care how the internals of the thing being tested work
	- You invoke the exposed {API} and check the result
	- testers have no access to the source code of a system or its components 
	- The tests are derived from the system specification. 
- {White} box testing
	- tests are based on knowledge of the structure of the program and its components
	- access to source code is essential
- {Unit} testing is a way of testing software components
	- testing of individual program units by the software developer or development team
<!--ID: 1640133750004-->

- Software quality in Agile Dev
	- agile manifesto to “maintain(…) simplicity is supported by constant refactoring that improves code quality and by using simple designs that do not unnecessarily anticipate future changes to the system.” 
	- Pair programming 
		- benefit quality and “serves as a continual design and code review process, and as a result defect rates are reduced”
	- Refactoring 
		- reduce chances that system can get seriously broken during the restructuring
		- during refactoring developers reconstruct the code and this action provides code inspection functionality
